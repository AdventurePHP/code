<?php
   /**
    * <!--
    * This file is part of the adventure php framework (APF) published under
    * http://adventure-php-framework.org.
    *
    * The APF is free software: you can redistribute it and/or modify
    * it under the terms of the GNU Lesser General Public License as published
    * by the Free Software Foundation, either version 3 of the License, or
    * (at your option) any later version.
    *
    * The APF is distributed in the hope that it will be useful,
    * but WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    * GNU Lesser General Public License for more details.
    *
    * You should have received a copy of the GNU Lesser General Public License
    * along with the APF. If not, see http://www.gnu.org/licenses/lgpl-3.0.txt.
    * -->
    */
    
   import('modules::genericormapper::data::tools','GenericORMapperSetup');

   /**
    * @package modules::genericormapper::data::tools
    * @class GenericORMapperUpdate
    *
    * The <strong>GenericORMapperUpdate</strong> can be used to update generic or mapper
    * installations that have been created using the <strong>GenericORMapperSetup</strong>
    * utility. Please note, that manual setups are not fully supported, due to the fact,
    * that table and/or columns names may be different to the default layout generated by
    * the setup tool.
    * <p/>
    * If you have adapted an automatic generated table layout, please remember the steps
    * and execute them after update. This is necessary for additional indexes, in case the
    * columns having a custom index are changed.
    * <p/>
    * In order to adapt the automatically generated change-set, please ensure the last param
    * to be <em>false</em>. This results in displaying the change statements rather to execute
    * them against the given database.
    *
    * @author Christian Achatz
    * @version
    * Version 0.1, 04.10.2009<br />
    */
   class GenericORMapperUpdate extends GenericORMapperSetup {

      /**
       * @var string[] Mapping table reconstructed from the given database connection.
       */
      private $__ReEngineeredMappingTable = array();
      private $__DatabaseMappingTables = array();

      /**
       * @var string[] Relation table reconstructed from the given database connection.
       */
      private $__ReEngineeredRelationTable = array();
      private $__DatabaseRelationTables = array();

      /**
       * @var string[] Stores the new mapping entries.
       */
      private $__NewMappings = array();

      /**
       * @var string[] Stores the removed mapping entries.
       */
      private $__RemovedMappings = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been added.
       */
      private $__NewMappingAttributes = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been removed.
       */
      private $__RemovedMappingAttributes = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been altered.
       */
      private $__AlteredMappingAttributes = array();

      /**
       * @var string[] Stores the new relation entries.
       */
      private $__NewRelations = array();

      /**
       * @var string[] Stores the removed relation entries.
       */
      private $__RemovedRelations = array();

      /**
       * @var string[] Stores the attributes of relation entries, that have been altered.
       */
      private $__AlteredRelationAttributes = array();

      /**
       * @var string[] Stores the update statements.
       */
      private $__UpdateStatements = array();

      /**
       * @public
       *
       * Updates a database, that was setup with the {@link GenericORMapperSetup} tool. You can
       * choose between direct update (<em>$updateInPlace=true</em>) and displaying the update
       * statements for manual update (<em>$updateInPlace=false</em>). Default is direct update.
       *
       * @param string $configNamespace namespace, where the desired mapper configuration is located
       * @param string $configNameAffix name affix of the object and relation definition files
       * @param string $connectionName name of the connection, that the mapper should use to access the database
       * @param boolean $updateInPlace Defines, if the update should be done for you (true) or if
       *                               the update statement should only be displayed (false).
       *                               Default is true.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 04.10.2009<br />
       */
      public function updateDatabase($configNamespace,$configNameAffix,$connectionName,$updateInPlace = true){

         // connection must be present, otherwise update is not possible
         if(empty($connectionName)){
            trigger_error('[GenericORMapperUpdate::updateDatabase()] Connection name may not be null!',
               E_USER_ERROR);
            exit(1);
         }

         // set the config namespace
         $this->__ConfigNamespace = $configNamespace;

         // set the config name affix
         $this->__ConfigNameAffix = $configNameAffix;

         // setup object layout (new)
         $this->__createMappingTable();

         // setup relation layout (new)
         $this->__createRelationTable();

         // generate layout from the database (reverse engineering of the database)
         $cM = &$this->__getServiceObject('core::database','connectionManager');
         $sql = &$cM->getConnection($connectionName);

         // analyze the current database
         $this->analyzeDatabaseTables($sql);

         // re-engineer the database tables concerning the relations
         $this->reEngineerRelations($sql);

         // re-engineer the database tables concerning the objects
         $this->reEngineerMappings($sql);

         // analyze the old and new mapping configuration
         $this->analyzeMappingConfigurationChanges();

         // generate mapping update statements
         $this->generateMappingUpdateStatements();

         // analyze old and new relation configuration
         $this->analyzeRelationConfigurationChanges();

         // generate relation update statements
         $this->generateRelationUpdateStatements();

         // print alter statements or execute them immediately
         if($updateInPlace === true){
            foreach($this->__UpdateStatements as $statement){
               $sql->executeTextStatement($statement);
            }
          // end if
         }
         else {
            echo '<pre>';
            foreach($this->__UpdateStatements as $statement){
               echo $statement.PHP_EOL.PHP_EOL.PHP_EOL;
            }
            echo '</pre>';
          // end else
         }

       // end function
      }

      /**
       * Compares two mapping keys. In case of mappings case sensitive comparison is done.
       *
       * @param string $a The first key.
       * @param string $b The second key.
       * @return int Compare status (0=equal, 1=different).
       */
      private function compareMappings($a,$b){
         if($a === $b){
            return 0;
         }
         return 1;
      }

      private function compareMappingValues($a,$b){
         return $this->compareMappings($a,$b);
      }

      /**
       * Compares two relation keys. In case of relations case insensitive comparison is done.
       *
       * @param string $a The first key.
       * @param string $b The second key.
       * @return int Compare status (0=equal, 1=different).
       */
      private function compareRelations($a,$b){
         $a = strtolower($a);
         $b = strtolower($b);
         if($a === $b){
            return 0;
         }
         return 1;
      }

      /**
       * Returns the type of
       *
       * @param string $primaryKeyName The
       * @return string The relation type declarator.
       */
      private function getRelationTypeLabel($primaryKeyName){
         $primaryKeyName = strtolower($primaryKeyName);
         if(substr_count($primaryKeyName,'ass') > 0){
            return 'ASSOCIATION';
         }
         return 'COMPOSITION';
      }

      /**
       * @private
       *
       * Returns the fields, that are relevant for comparison.
       *
       * @param string[] $fields
       * @return string[] The fields relevant for comparison.
       *
       * @version
       * Version 0.1, 10.10.2009<br />
       * Version 0.2, 13.10.2009 (Corrected check for primary key)<br />
       */
      private function getRelevantFields($fields){
         $resultFields = array();

         foreach($fields as $field){
            if($field['Key'] != 'PRI' // do exclude primary key, but allow MUL indices!
               && $field['Field'] != 'CreationTimestamp'
               && $field['Field'] != 'ModificationTimestamp'){
               $resultFields[] = $field;
            }
         }

         return $resultFields;
      }

      /**
       * @private
       *
       * Returns the name of the primary key.
       *
       * @param string[] $fields The current definition's fields.
       * @return string The name of the primary key.
       */
      private function getPrimaryKeyName($fields){
         foreach($fields as $field){
            if($field['Key'] == 'PRI'){
               return $field['Field'];
            }
         }
      }

      /**
       * @private
       *
       * Analyzes the given database and stores the tables included.
       *
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function analyzeDatabaseTables(AbstractDatabaseHandler $sql){

         $selectTables = 'SHOW TABLES;';
         $resultTables = $sql->executeTextStatement($selectTables);

         while($dataTables = $sql->fetchData($resultTables)){

            // gather the offset we are provided by the database due
            // to the fact, that we ordered an associative array!
            $keys = array_keys($dataTables);
            $offset = $keys[0];

            // collect tables
            if(substr_count($dataTables[$offset],'ent_') == 1){
               $this->__DatabaseMappingTables[] = $dataTables[$offset];
            }
            elseif(substr_count($dataTables[$offset],'ass_') == 1){
               $this->__DatabaseRelationTables[] = $dataTables[$offset];
            }
            elseif(substr_count($dataTables[$offset],'cmp_') == 1){
               $this->__DatabaseRelationTables[] = $dataTables[$offset];
            }
            else{
               trigger_error('Table '.$dataTables[$offset].' is not a GORM table!');
            }
            
          // end while
         }
         
       // end function
      }

      /**
       * @private
       * 
       * Creates a relation mapping out of the database tables.
       *
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function reEngineerRelations(AbstractDatabaseHandler $sql){

         // create reverse engineered mapping entries
         foreach($this->__DatabaseRelationTables as $relationTable){

            $selectCreate = 'SHOW COLUMNS FROM '.$relationTable;
            $resultCreate = $sql->executeTextStatement($selectCreate);

            $fields = array();
            while($dataCreate = $sql->fetchData($resultCreate)){
               $fields[] = $dataCreate;
            }

            $primaryKey = $this->getPrimaryKeyName($fields);
            $relationName = substr($relationTable,4);
            $sourceId = $fields[1]['Field'];
            $targetId = $fields[2]['Field'];

            $this->__ReEngineeredRelationTable[$relationName] = array(
               'Type' => $this->getRelationTypeLabel($primaryKey),
               'Table' => $relationTable,
               'SourceID' => $sourceId,
               'TargetID' => $targetId,
               'SourceObject' => str_replace('ID','',$sourceId),
               'TargetObject' => str_replace('ID','',$targetId),
            );

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Creates a object mapping out of the database tables.
       * 
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function reEngineerMappings(AbstractDatabaseHandler $sql){

         foreach($this->__DatabaseMappingTables as $objectTable){

            $selectCreate = 'SHOW COLUMNS FROM '.$objectTable;
            $resultCreate = $sql->executeTextStatement($selectCreate);

            $fields = array();
            while($dataCreate = $sql->fetchData($resultCreate)){
               $fields[] = $dataCreate;
            }
            $mainFields = $this->getRelevantFields($fields);
            $primaryKey = $this->getPrimaryKeyName($fields);
            $objectName = str_replace('ID','',$primaryKey);

            $objectFields = array();
            foreach($mainFields as $field){
               
               $objectFields[$field['Field']] = strtoupper($field['Type']);


/*Wenn das Feld NULL sein darf, bewirkt KEINE Angabe eines DEFAULTs, dass DEFAULT NULL gesetzt wird. Wird hingegen
ein benutzerdefinierter String genutzt, wird dieser in der Spalte "Default" ausgegeben. Dazu zählt auch ein leerer
String. Sprich: Steht hier kein "NULL", ist es DEFAULT ''. Steht hier ein NULL, kann es jedoch nichts oder aber
DEFAULT NULL sein. Kann man da vielleicht eine Ausnahme programmieren? Sonst wäre es doof, wenn man stetig den
DEFAULT-Value angeben müsste!? Bei den Feldern, die NICHT NULL sein dürfen, ist es etwas konfus: Ich darf zwar kein
DEFAULT NULL angeben, aber lasse ich DEFAUL weg, bekomme ich als Standard "NULL" zurückgeliefert. Sehr merkwürdig, aber
in diesem Falle ist es wohl so, dass dies bedeuten soll, dass hier KEIN DEFAULT gesetzt wird. Ansonsten gilt bei Angabe
einer Zeichenkette das Gleiche wie bei NULL-Feldern.*/               


               /*
                  CREATE TABLE IF NOT EXISTS `test` (
                    `ID` int(10) unsigned NOT NULL AUTO_INCREMENT,
                    `Test1` varchar(10) ,
                    `Test2` varchar(10) DEFAULT '',
                    `Test3` varchar(10) DEFAULT NULL,
                    `Test4` varchar(10) NOT NULL,
                    `Test5` varchar(10) NOT NULL DEFAULT '',
                    PRIMARY KEY (`ID`)
                  ) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

                  +-------+------------------+------+-----+---------+----------------+
                  | Field | Type             | Null | Key | Default | Extra          |
                  +-------+------------------+------+-----+---------+----------------+
                  | ID    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |
                  | Test1 | varchar(10)      | YES  |     | NULL    |                |
                  | Test2 | varchar(10)      | YES  |     |         |                |
                  | Test3 | varchar(10)      | YES  |     | NULL    |                |
                  | Test4 | varchar(10)      | NO   |     | NULL    |                |
                  | Test5 | varchar(10)      | NO   |     |         |                |
                  +-------+------------------+------+-----+---------+----------------+
               */

               // correct empty NULL values as NO for MySQL4
               if(empty($field['Null'])){
                  $field['Null'] = 'NO';                  
               }

               // 
               /*if($field['Null'] == 'YES' && $field['Default'] == 'NULL'){
                  $objectFields[$field['Field']] .= '';
               }
               elseif($field['Null'] == 'YES' && empty($field['Default'])){
                  $objectFields[$field['Field']] .= 'DEFAULT \'\'';
               }
               elseif($field['Null'] == 'NO' && $field['Default'] == 'NULL'){
                     $objectFields[$field['Field']] .= 'NOT NULL';
               }
               elseif($field['Null'] == 'NO' && empty($field['Default'])){
                     $objectFields[$field['Field']] .= 'NOT NULL DEFAULT \'\'';
               }*/

               // add a null/not null indicator to preserve the correct datatype
               if($field['Null'] == 'NO'){
                  $objectFields[$field['Field']] .= ' NOT NULL';
               }
               else {
                  $objectFields[$field['Field']] .= ' NULL';
               }

               // add default indicator to preserve correct data type
               if(!empty($field['Default'])){
                  $objectFields[$field['Field']] .= ' DEFAULT \''.$field['Default'].'\'';
               }
               else{
                  $objectFields[$field['Field']] .= ' DEFAULT \'\'';
               }

             // end foreach
            }

            $this->__ReEngineeredMappingTable[$objectName] = array_merge(
               array(
                  'ID' => $primaryKey,
                  'Table' => $objectTable
               ),
               $objectFields
            );

          // end foreach
         }

       // end function
      }

      /**
       * @private
       * 
       * Generates update statements for the mapping configuration.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 04.10.2009<br />
       * Version 0.2, 13.10.2009 (Added ticks to delimit table names.)<br />
       */
      private function generateMappingUpdateStatements(){

         foreach($this->__NewMappings as $newMapping => $DUMMY){
            $this->__UpdateStatements[] =
               $this->__generateMappingTableLayout(
                  $this->__MappingTable[$newMapping]
               );
         }
         foreach($this->__RemovedMappings as $removedMapping => $DUMMY){
            $this->__UpdateStatements[] = 'DROP TABLE '
               .$this->__ReEngineeredMappingTable[$removedMapping]['Table']
               .';';
         }
         foreach($this->__NewMappingAttributes as $newAttribute => $values){

            if(count($values) > 0){

               foreach($values as $name => $dataType){
                  $dataType = preg_replace(
                     $this->__RowTypeMappingFrom,
                     $this->__RowTypeMappingTo,
                     $dataType
                  );
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$newAttribute]['Table'].'` ADD `'
                     .$name.'` '.$dataType.';';
                // end for
               }

             // end if
            }

          // end foreach
         }
         foreach($this->__RemovedMappingAttributes as $removedAttribute => $values){
            
            if(count($values) > 0){

               foreach($values as $name => $dataType){
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$removedAttribute]['Table'].'` DROP `'.$name.'`;';
                // end foreach
               }
               
             // end if
            }
         
          // end foreach
         }
         foreach($this->__AlteredMappingAttributes as $alteredAttribute => $values){

            if(count($values) > 0){

               foreach($values as $name){
                  $dataType = preg_replace(
                     $this->__RowTypeMappingFrom,
                     $this->__RowTypeMappingTo,
                     $this->__MappingTable[$alteredAttribute][$name]
                  );
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$alteredAttribute]['Table'].'` CHANGE `'.$name.'` '
                     .'`'.$name.'` '.$dataType.';';

                // end if
               }

             // end foreach
            }
         
          // end foreach
         }
         
       // end function
      }

      /**
       * @private
       *
       * Analyzes the old and new mapping configuration and stores the changes locally.
       */
      private function analyzeMappingConfigurationChanges(){
         
         // gather overall mapping changes
         $this->__NewMappings = array_diff_ukey(
            $this->__MappingTable,
            $this->__ReEngineeredMappingTable,
            array($this,'compareMappings')
         );
         $this->__RemovedMappings = array_diff_ukey(
            $this->__ReEngineeredMappingTable,
            $this->__MappingTable,
            array($this,'compareMappings')
         );

         // evaluate changes within the attributes
         foreach($this->__MappingTable as $mappingKey => $mappingValue){

            // only scan entries, that are not within the new and removed ones!
            if(!isset($this->__NewMappings[$mappingKey])
               && !isset($this->__RemovedMappings[$mappingKey])){

               // new columns
               $this->__NewMappingAttributes[$mappingKey] = array_diff_ukey(
                  $this->__MappingTable[$mappingKey],
                  $this->__ReEngineeredMappingTable[$mappingKey],
                  array($this,'compareMappings')
               );

               // removed columns
               $this->__RemovedMappingAttributes[$mappingKey] = array_diff_ukey(
                  $this->__ReEngineeredMappingTable[$mappingKey],
                  $this->__MappingTable[$mappingKey],
                  array($this,'compareMappings')
               );

               // changed columns
               foreach($this->__MappingTable[$mappingKey] as $key => $value){

                  // only scan entries, that are also existent within the re-engineered mapping table!
                  if(isset($this->__ReEngineeredMappingTable[$mappingKey][$key])){
                     $diff = $this->compareMappingValues(
                        $this->__MappingTable[$mappingKey][$key],
                        $this->__ReEngineeredMappingTable[$mappingKey][$key]
                     );
                     if($diff === 1){
                        $this->__AlteredMappingAttributes[$mappingKey][] = $key;
                     }
                   // end if
                  }

                // end foreach
               }

             // end if
            }

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Analyzes the old and new relation configuration and stores the changes locally.
       * With relations, only type changes can be applied. Otherwise the data structure
       * gets corrupted!
       */
      private function analyzeRelationConfigurationChanges(){

         // new relations
         $this->__NewRelations = array_diff_ukey(
            $this->__RelationTable,
            $this->__ReEngineeredRelationTable,
            array($this,'compareRelations')
         );

         // removed relations
         $this->__RemovedRelations = array_diff_ukey(
            $this->__ReEngineeredRelationTable,
            $this->__RelationTable,
            array($this,'compareRelations')
         );

         // evaluate changes within the attributes
         foreach($this->__RelationTable as $relationKey => $relationValue){

            // use lowercase relation key for re-engineered values!
            $reEngRelationKey = strtolower($relationKey);

            // only scan entries, that are not within the new and removed ones!
            if(!isset($this->__NewRelations[$relationKey])
               && !isset($this->__RemovedRelations[$relationKey])){

               // changed columns (we only check for relation type, because for all other
               // cases, a new relation *must* be created!)
               foreach($this->__RelationTable[$relationKey] as $key => $DUMMY){

                  // only scan entries, that are also existent within the re-engineered
                  // relation table! Further, only respect the type key.
                  if(isset($this->__ReEngineeredRelationTable[$reEngRelationKey][$key])
                     && $key == 'Type'){
                     if($this->__ReEngineeredRelationTable[$reEngRelationKey][$key]
                        !== $this->__RelationTable[$relationKey][$key]){
                        $this->__AlteredRelationAttributes[] = $relationKey;
                     }
                   // end if
                  }

                // end foreach
               }

             // end if
            }

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Generates update statements for relation changes.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 11.10.2009<br />
       */
      private function generateRelationUpdateStatements(){

         foreach($this->__NewRelations as $newRelation => $DUMMY){
            $this->__UpdateStatements[] = 
               $this->__generateRelationTableLayout($this->__RelationTable[$newRelation]);
         }
         foreach($this->__RemovedRelations as $removedRelation => $DUMMY){
            $this->__UpdateStatements[] = 'DROP TABLE '
               .$this->__ReEngineeredRelationTable[$removedRelation]['Table'].';';
         }

         // changed relation types: $this->__AlteredRelationAttributes
         foreach($this->__AlteredRelationAttributes as $alteredRelation){
            $reEngAlteredRelation = strtolower($alteredRelation);
            $this->__UpdateStatements[] = 'RENAME TABLE `'
               .$this->__ReEngineeredRelationTable[$reEngAlteredRelation]['Table']
               .'` TO `'.$this->__RelationTable[$alteredRelation]['Table'].'`;';
         }

       // end function
      }

    // end class
   }
?>