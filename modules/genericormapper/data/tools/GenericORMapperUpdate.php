<?php
   /**
    * <!--
    * This file is part of the adventure php framework (APF) published under
    * http://adventure-php-framework.org.
    *
    * The APF is free software: you can redistribute it and/or modify
    * it under the terms of the GNU Lesser General Public License as published
    * by the Free Software Foundation, either version 3 of the License, or
    * (at your option) any later version.
    *
    * The APF is distributed in the hope that it will be useful,
    * but WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    * GNU Lesser General Public License for more details.
    *
    * You should have received a copy of the GNU Lesser General Public License
    * along with the APF. If not, see http://www.gnu.org/licenses/lgpl-3.0.txt.
    * -->
    */
    
   import('modules::genericormapper::data::tools','GenericORMapperSetup');

   /**
    * @namespace modules::genericormapper::data::tools
    * @class GenericORMapperUpdate
    *
    * The <strong>GenericORMapperUpdate</strong> can be used to update generic or mapper
    * installations that have been created using the <strong>GenericORMapperSetup</strong>
    * utility. Please note, that manual setups are not fully supported, due to the fact,
    * that table and/or columns names may be different to the default layout generated by
    * the setup tool.
    * <p/>
    * If you have adapted an automatic generated table layout, please remember the steps
    * and execute them after update. This is necessary for additional indices, in case the
    * columns having a custom index are changed.
    * <p/>
    * In order to adapt the automatically generated changeset, please ensure the last param
    * to be <em>false</em>. This results in displaying the change statements rather to execute
    * them agains the given database.
    *
    * @author Christian Achatz
    * @version
    * Version 0.1, 04.10.2009<br />
    */
   class GenericORMapperUpdate extends GenericORMapperSetup {

      /**
       * @var string[] Mapping table reconstructed from the given database connection.
       */
      private $__ReEngineeredMappingTable = array();
      private $__DatabaseMappingTables = array();

      /**
       * @var string[] Relation table reconstructed from the given database connection.
       */
      private $__ReEngineeredRelationTable = array();
      private $__DatabaseRelationTables = array();

      /**
       * @var string[] Stores the new mapping entries.
       */
      private $__NewMappings = array();

      /**
       * @var string[] Stores the removed mapping entries.
       */
      private $__RemovedMappings = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been added.
       */
      private $__NewMappingAttributes = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been removed.
       */
      private $__RemovedMappingAttributes = array();

      /**
       * @var string[] Stores the attributes of mapping entries, that have been altered.
       */
      private $__AlteredMappingAttributes = array();

      /**
       * @var string[] Stores the new relation entries.
       */
      private $__NewRelations = array();

      /**
       * @var string[] Stores the removed relation entries.
       */
      private $__RemovedRelations = array();

      /**
       * @var string[] Stores the attributes of relation entries, that have been altered.
       */
      private $__AlteredRelationAttributes = array();

      /**
       * @var string[] Stores the update statements.
       */
      private $__UpdateStatements = array();

      /**
       * @public
       *
       * Updates a database, that was setup with the {@link GenericORMapperSetup} tool. You can
       * choose between direct update (<em>$updateInPlace=true</em>) and displaying the update
       * statements for manual update (<em>$updateInPlace=false</em>). Default is direct update.
       *
       * @param string $configNamespace namespace, where the desired mapper configuration is located
       * @param string $configNameAffix name affix of the object and relation definition files
       * @param string $connectionName name of the connection, that the mapper should use to access the database
       * @param boolean $updateInPlace Defines, if the update should be done for you (true) or if
       *                               the update statement should only be displayed (false).
       *                               Default is true.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 04.10.2009<br />
       */
      public function updateDatabase($configNamespace,$configNameAffix,$connectionName,$updateInPlace = true){

         // connection must be present, otherwise update is not possible
         if(empty($connectionName)){
            trigger_error('[GenericORMapperUpdate::updateDatabase()] Connection name may not be null!',
               E_USER_ERROR);
            exit(1);
         }

         // set the config namespace
         $this->__ConfigNamespace = $configNamespace;

         // set the config name affix
         $this->__ConfigNameAffix = $configNameAffix;

         // setup object layout (new)
         $this->__createMappingTable();

         // setup relation layout (new)
         $this->__createRelationTable();

         // generate layout from the database (reverse engeneering of the database)
         $cM = &$this->__getServiceObject('core::database','connectionManager');
         $sql = &$cM->getConnection($connectionName);

         // analyze the current database
         $this->analyzeDatabaseTables($sql);

         // re-engineer the database tables concerning the relations
         $this->reEngineerRelations($sql);

         // re-engineer the database tables concerning the objects
         $this->reEngineerMappings($sql);

         // analyze the old and new mapping configuration
         $this->analyzeMappingConfigurationChanges();

         // generate mapping update statements
         $this->generateMappingUpdateStatements();

         // analyze old and new relation configuration
         $this->analyzeRelationConfigurationChanges();

         // generate relation update statements
         $this->generateRelationUpdateStatements();

         // print alter statements or execute them immediately
         if($updateInPlace === true){
            foreach($this->__UpdateStatements as $statement){
               $sql->executeTextStatement($statement);
            }
          // end if
         }
         else {
            echo '<pre>';
            foreach($this->__UpdateStatements as $statement){
               echo $statement.PHP_EOL.PHP_EOL.PHP_EOL;
            }
            echo '</pre>';
          // end else
         }

       // end function
      }

      /**
       * Compares two mapping keys. In case of mappings case sensitive comparison is done.
       *
       * @param string $a The first key.
       * @param string $b The second key.
       * @return int Compare status (0=equal, 1=different).
       */
      private function compareMappings($a,$b){
         if($a === $b){
            return 0;
         }
         return 1;
      }

      private function compareMappingValues($a,$b){
         return $this->compareMappings($a,$b);
      }

      /**
       * Compares two relation keys. In case of relations case insensitive comparison is done.
       *
       * @param string $a The first key.
       * @param string $b The second key.
       * @return int Compare status (0=equal, 1=different).
       */
      private function compareRelations($a,$b){
         $a = strtolower($a);
         $b = strtolower($b);
         if($a === $b){
            return 0;
         }
         return 1;
      }

      /**
       * Returns the type of
       *
       * @param string $primaryKeyName The
       * @return string The relation type declarator.
       */
      private function getRelationTypeLabel($primaryKeyName){
         $primaryKeyName = strtolower($primaryKeyName);
         if(substr_count($primaryKeyName,'ass') > 0){
            return 'ASSOCIATION';
         }
         return 'COMPOSITION';
      }

      /**
       * @private
       *
       * Returns the fields, that are relevant for comparison.
       *
       * @param string[] $fields
       * @return string[] The fields relevant for comparison.
       *
       * @version
       * Version 0.1, 10.10.2009<br />
       * Version 0.2, 13.10.2009 (Corrected check for primary key)<br />
       */
      private function getRelevantFields($fields){
         $resultFields = array();

         foreach($fields as $field){
            if($field['Key'] != 'PRI' // do exclude primary key, but allow MUL indices!
               && $field['Field'] != 'CreationTimestamp'
               && $field['Field'] != 'ModificationTimestamp'){
               $resultFields[] = $field;
            }
         }

         return $resultFields;
      }

      /**
       * @private
       *
       * Returns the name of the primary key.
       *
       * @param string[] $fields The current definition's fields.
       * @return string The name of the primary key.
       */
      private function getPrimaryKeyName($fields){
         foreach($fields as $field){
            if($field['Key'] == 'PRI'){
               return $field['Field'];
            }
         }
      }

      /**
       * @private
       *
       * Analyzes the given database and stores the tables included.
       *
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function analyzeDatabaseTables(AbstractDatabaseHandler $sql){

         $selectTables = 'SHOW TABLES;';
         $resultTables = $sql->executeTextStatement($selectTables);

         while($dataTables = $sql->fetchData($resultTables)){

            // gather the offset we are provided by the database due
            // to the fact, that we ordered an associative array!
            $keys = array_keys($dataTables);
            $offset = $keys[0];

            // collect tables
            if(substr_count($dataTables[$offset],'ent_') == 1){
               $this->__DatabaseMappingTables[] = $dataTables[$offset];
            }
            elseif(substr_count($dataTables[$offset],'ass_') == 1){
               $this->__DatabaseRelationTables[] = $dataTables[$offset];
            }
            elseif(substr_count($dataTables[$offset],'cmp_') == 1){
               $this->__DatabaseRelationTables[] = $dataTables[$offset];
            }
            else{
               trigger_error('Table '.$dataTables[$offset].' is not a GORM table!');
            }
            
          // end while
         }
         
       // end function
      }

      /**
       * @private
       * 
       * Creates a relation mapping out of the database tables.
       *
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function reEngineerRelations(AbstractDatabaseHandler $sql){

         // create reverse engineered mapping entries
         foreach($this->__DatabaseRelationTables as $relationTable){

            $selectCreate = 'SHOW COLUMNS FROM '.$relationTable;
            $resultCreate = $sql->executeTextStatement($selectCreate);

            $fields = array();
            while($dataCreate = $sql->fetchData($resultCreate)){
               $fields[] = $dataCreate;
            }

            $primaryKey = $this->getPrimaryKeyName($fields);
            $relationName = substr($relationTable,4);
            $sourceId = $fields[1]['Field'];
            $targetId = $fields[2]['Field'];

            $this->__ReEngineeredRelationTable[$relationName] = array(
               'Type' => $this->getRelationTypeLabel($primaryKey),
               'Table' => $relationTable,
               'SourceID' => $sourceId,
               'TargetID' => $targetId,
               'SourceObject' => str_replace('ID','',$sourceId),
               'TargetObject' => str_replace('ID','',$targetId),
            );

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Creates a object mapping out of the database tables.
       * 
       * @param AbstractDatabaseHandler $sql The database connection to analyze.
       */
      private function reEngineerMappings(AbstractDatabaseHandler $sql){

         foreach($this->__DatabaseMappingTables as $objectTable){

            $selectCreate = 'SHOW COLUMNS FROM '.$objectTable;
            $resultCreate = $sql->executeTextStatement($selectCreate);

            $fields = array();
            while($dataCreate = $sql->fetchData($resultCreate)){
               $fields[] = $dataCreate;
            }
            $mainFields = $this->getRelevantFields($fields);
            $primaryKey = $this->getPrimaryKeyName($fields);
            $objectName = str_replace('ID','',$primaryKey);

            $objectFields = array();
            foreach($mainFields as $field){
               
               $objectFields[$field['Field']] = strtoupper($field['Type']);

               // add a null/not null indicator to preserve the correct datatype
               if(empty($field['Null'])){
                  $objectFields[$field['Field']] .= ' NOT NULL';
               }
               else {
                  $objectFields[$field['Field']] .= ' NULL';
               }

               // add default indicator to preserve correct data type
               if(!empty($field['Default'])){
                  $objectFields[$field['Field']] .= ' DEFAULT \''.$field['Default'].'\'';
               }

             // end foreach
            }

            $this->__ReEngineeredMappingTable[$objectName] = array_merge(
               array(
                  'ID' => $primaryKey,
                  'Table' => $objectTable
               ),
               $objectFields
            );

          // end foreach
         }

       // end function
      }

      /**
       * @private
       * 
       * Generates update statements for the mapping configuration.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 04.10.2009<br />
       * Version 0.2, 13.10.2009 (Added ticks to delimit table names.)<br />
       */
      private function generateMappingUpdateStatements(){

         foreach($this->__NewMappings as $newMapping => $DUMMY){
            $this->__UpdateStatements[] =
               $this->__generateMappingTableLayout(
                  $this->__MappingTable[$newMapping]
               );
         }
         foreach($this->__RemovedMappings as $removedMapping => $DUMMY){
            $this->__UpdateStatements[] = 'DROP TABLE '
               .$this->__ReEngineeredMappingTable[$removedMapping]['Table']
               .';';
         }
         foreach($this->__NewMappingAttributes as $newAttribute => $values){

            if(count($values) > 0){

               foreach($values as $name => $dataType){
                  $dataType = preg_replace(
                     $this->__RowTypeMappingFrom,
                     $this->__RowTypeMappingTo,
                     $dataType
                  );
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$newAttribute]['Table'].'` ADD `'
                     .$name.'` '.$dataType.';';
                // end for
               }

             // end if
            }

          // end foreach
         }
         foreach($this->__RemovedMappingAttributes as $removedAttribute => $values){
            
            if(count($values) > 0){

               foreach($values as $name => $dataType){
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$removedAttribute]['Table'].'` DROP `'.$name.'`;';
                // end foreach
               }
               
             // end if
            }
         
          // end foreach
         }
         foreach($this->__AlteredMappingAttributes as $alteredAttribute => $values){

            if(count($values) > 0){

               foreach($values as $name){
                  $dataType = preg_replace(
                     $this->__RowTypeMappingFrom,
                     $this->__RowTypeMappingTo,
                     $this->__MappingTable[$alteredAttribute][$name]
                  );
                  $this->__UpdateStatements[] = 'ALTER TABLE `'
                     .$this->__MappingTable[$alteredAttribute]['Table'].'` CHANGE `'.$name.'` '
                     .'`'.$name.'` '.$dataType.';';

                // end if
               }

             // end foreach
            }
         
          // end foreach
         }
         
       // end function
      }

      /**
       * @private
       *
       * Analyzes the old and new mapping configuration and stores the changes locally.
       */
      private function analyzeMappingConfigurationChanges(){
         
         // gather overall mapping changes
         $this->__NewMappings = array_diff_ukey(
            $this->__MappingTable,
            $this->__ReEngineeredMappingTable,
            array($this,'compareMappings')
         );
         $this->__RemovedMappings = array_diff_ukey(
            $this->__ReEngineeredMappingTable,
            $this->__MappingTable,
            array($this,'compareMappings')
         );

         // evaluate changes within the attributes
         foreach($this->__MappingTable as $mappingKey => $mappingValue){

            // only scan entries, that are not within the new and removed ones!
            if(!isset($this->__NewMappings[$mappingKey])
               && !isset($this->__RemovedMappings[$mappingKey])){

               // new columns
               $this->__NewMappingAttributes[$mappingKey] = array_diff_ukey(
                  $this->__MappingTable[$mappingKey],
                  $this->__ReEngineeredMappingTable[$mappingKey],
                  array($this,'compareMappings')
               );

               // removed columns
               $this->__RemovedMappingAttributes[$mappingKey] = array_diff_ukey(
                  $this->__ReEngineeredMappingTable[$mappingKey],
                  $this->__MappingTable[$mappingKey],
                  array($this,'compareMappings')
               );

               // changed columns
               foreach($this->__MappingTable[$mappingKey] as $key => $value){

                  // only scan entries, that are also existent within the re-engineered mapping table!
                  if(isset($this->__ReEngineeredMappingTable[$mappingKey][$key])){
                     $diff = $this->compareMappingValues(
                        $this->__MappingTable[$mappingKey][$key],
                        $this->__ReEngineeredMappingTable[$mappingKey][$key]
                     );
                     if($diff === 1){
                        $this->__AlteredMappingAttributes[$mappingKey][] = $key;
                     }
                   // end if
                  }

                // end foreach
               }

             // end if
            }

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Analyzes the old and new relation configuration and stores the changes locally.
       * With relations, only type changes can be applied. Otherwise the data structure
       * gets corrupted!
       */
      private function analyzeRelationConfigurationChanges(){

         // new relations
         $this->__NewRelations = array_diff_ukey(
            $this->__RelationTable,
            $this->__ReEngineeredRelationTable,
            array($this,'compareRelations')
         );

         // removed relations
         $this->__RemovedRelations = array_diff_ukey(
            $this->__ReEngineeredRelationTable,
            $this->__RelationTable,
            array($this,'compareRelations')
         );

         // evaluate changes within the attributes
         foreach($this->__RelationTable as $relationKey => $relationValue){

            // use lowercase relation key for re-engineered values!
            $reEngRelationKey = strtolower($relationKey);

            // only scan entries, that are not within the new and removed ones!
            if(!isset($this->__NewRelations[$relationKey])
               && !isset($this->__RemovedRelations[$relationKey])){

               // changed columns (we only check for relation type, because for all other
               // cases, a new relation *must* be created!)
               foreach($this->__RelationTable[$relationKey] as $key => $DUMMY){

                  // only scan entries, that are also existent within the re-engineered
                  // relation table! Further, only respect the type key.
                  if(isset($this->__ReEngineeredRelationTable[$reEngRelationKey][$key])
                     && $key == 'Type'){
                     if($this->__ReEngineeredRelationTable[$reEngRelationKey][$key]
                        !== $this->__RelationTable[$relationKey][$key]){
                        $this->__AlteredRelationAttributes[] = $relationKey;
                     }
                   // end if
                  }

                // end foreach
               }

             // end if
            }

          // end foreach
         }

       // end function
      }

      /**
       * @private
       *
       * Generates update statements for relation changes.
       *
       * @author Christian Achatz
       * @version
       * Version 0.1, 11.10.2009<br />
       */
      private function generateRelationUpdateStatements(){

         foreach($this->__NewRelations as $newRelation => $DUMMY){
            $this->__UpdateStatements[] = 
               $this->__generateRelationTableLayout($this->__RelationTable[$newRelation]);
         }
         foreach($this->__RemovedRelations as $removedRelation => $DUMMY){
            $this->__UpdateStatements[] = 'DROP TABLE '
               .$this->__ReEngineeredRelationTable[$removedRelation]['Table'].';';
         }

         // changed relation types: $this->__AlteredRelationAttributes
         foreach($this->__AlteredRelationAttributes as $alteredRelation){
            $reEngAlteredRelation = strtolower($alteredRelation);
            $this->__UpdateStatements[] = 'RENAME TABLE `'
               .$this->__ReEngineeredRelationTable[$reEngAlteredRelation]['Table']
               .'` TO `'.$this->__RelationTable[$alteredRelation]['Table'].'`;';
         }

       // end function
      }

    // end class
   }
?>